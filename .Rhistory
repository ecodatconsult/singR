# Create a table in the database (optional if the table doesn't exist)
dbWriteTable(con, "my_table", upload_data)
# Define idfields
idfields <- c("id")
# Call db_filter_upload function to upload data to the database
db_filter_upload(upload_data, con, "my_table", idfields, verbose = TRUE)
# Disconnect from the database
dbDisconnect(con)
devtools::document()
devtools::document()
devtools::document()
usethis::use_test("extract_path_info")
devtools::load_all()
test_that("create_id_from_path generates expected IDs", {
# Define test cases
paths <- c(
"path/to/file1.txt",
"path/to/file2.txt",
"another/path/to/file3.txt"
)
expected_ids <- c(
"1a79a4d60de6718e8e5b326e338ae533", # MD5 hash of "path_to_file1.txt"
"f5b47b452a7c81bc8cb5e92f0b206ab1", # MD5 hash of "path_to_file2.txt"
"46ed6de06ebcd6ce8c30c0b9a9ed0371"  # MD5 hash of "another_path_to_file3.txt"
)
# Test the function for each path
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[i],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
})
# Define test cases
paths <- c(
"path/to/file1.txt",
"path/to/file2.txt",
"another/path/to/file3.txt"
)
expected_ids <- c(
"1a79a4d60de6718e8e5b326e338ae533", # MD5 hash of "path_to_file1.txt"
"f5b47b452a7c81bc8cb5e92f0b206ab1", # MD5 hash of "path_to_file2.txt"
"46ed6de06ebcd6ce8c30c0b9a9ed0371"  # MD5 hash of "another_path_to_file3.txt"
)
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[i],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
id <- create_id_from_path(paths[i])
id
# Define test cases with longer paths
paths <- c(
"path/to/first/level/file1.txt",
"path/to/second/level/file2.txt",
"another/path/to/third/level/file3.txt"
)
expected_ids <- c(
"a69a2b3dc1a91b16f259b16e8cf0eb8d", # MD5 hash of "path_to_first_level_file1.txt"
"e2d549b6e6d777706b42a44078291b72", # MD5 hash of "path_to_second_level_file2.txt"
"9b3c0ff10c4969e1e0ac19293b3d6972"  # MD5 hash of "another_path_to_third_level_file3.txt"
)
# Test the function for each path
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[i],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
digest::digest(paths, algo = "md5")
digest::digest(paths[1], algo = "md5")
# Define test cases with longer paths
paths <- c(
"path/to/first/level/file1.txt",
"path/to/second/level/file2.txt",
"another_path_to_third_level_file3.txt"
)
digest::digest(paths[3], algo = "md5")
expected_ids <- c(
"a69a2b3dc1a91b16f259b16e8cf0eb8d", # MD5 hash of "path_to_first_level_file1.txt"
"e2d549b6e6d777706b42a44078291b72", # MD5 hash of "path_to_second_level_file2.txt"
"c777f0f731fe207afdc973a5e2c1ae08"  # MD5 hash of "another_path_to_third_level_file3.txt"
)
digest::digest(paths[3], algo = "md5")
i = 3
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[3],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
create_id_from_path(paths[i])
paths[i]
# Define test cases with longer paths
paths <- c(
"path/to/first/level/file1.txt",
"path/to/second/level/file2.txt",
"another/path/to/third/level/file3.txt"
)
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[3],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
id
# Define test cases with longer paths
paths <- c(
"a/path/to/third/level/file3.txt"
)
# Define test cases with longer paths
paths <- c(
"another/path/to/third/level/file3.txt"
)
digest::digest(paths[3], algo = "md5")
expected_ids <- c(
"c777f0f731fe207afdc973a5e2c1ae08"  # MD5 hash of "another_path_to_third_level_file3.txt"
)
# Test the function for each path
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[3],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
expected_ids <- c(
"c777f0f731fe207afdc973a5e2c1ae08"  # MD5 hash of "another_path_to_third_level_file3.txt"
)
# Test the function for each path
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[3],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
# Test the function for each path
for (i in seq_along(paths)) {
id <- create_id_from_path(paths[i])
expect_equal(id, expected_ids[i],
info = paste("Expected ID:", expected_ids[i], "| Generated ID:", id))
}
devtools::test()
usethis::use_test("db_tools")
# Mocking RSQLite::dbWriteTable to capture arguments
RSQLite::dbWriteTable <- function(con, table, upload_data) {
expect_equal(table, "test_table")
expect_equal(nrow(upload_data), 5)
}
# Mocking RSQLite::dbListTables to return an empty list
RSQLite::dbListTables <- function(con) character(0)
RSQLite::dbListTables
# Mocking RSQLite::dbListTables to return an empty list
RSQLite::dbListTables <- function(con) character(0)
# Execute the function
db_filter_upload(upload_data = data.frame(x = 1:5), con = NULL, table = "test_table", idfields = "x", verbose = FALSE)
# Mocking RSQLite::dbListTables to return an empty list
RSQLite::dbListTables <- function(con) character(0)
library(testthat)
# Load the function
source("db_filter_upload.R")
context("db_filter_upload function tests")
# Mocking RSQLite::dbListTables to return an empty list
RSQLite::dbListTables <- function(con) character(0)
test_that("db_filter_upload initializes a new table when it doesn't exist in the database") {
test_that("db_filter_upload appends data to an existing table after filtering out duplicates") {
test_that("db_filter_upload handles verbose mode correctly") {
usethis::use_test("format_deployment")
# Create a temporary CSV file for testing
tmpfile <- tempfile(fileext = ".csv")
writeLines("date,time,lat,lon
2023-Jan-01,10:00:00,40.7128,-74.0060
2023-Jan-02,12:00:00,34.0522,-118.2437", tmpfile)
# Test the function
formatted_data <- format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_is(formatted_data, "sf")
# Create a temporary CSV file for testing
tmpfile <- tempfile(fileext = ".csv")
writeLines("date,time,lat,lon
2023-Jan-01,10:00:00,40.7128,-74.0060
2023-Jan-02,12:00:00,34.0522,-118.2437", tmpfile)
# Test the function
formatted_data <- format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_s3_class(formatted_data, "sf")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path") %in% names(formatted_data)))
format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_s3_class(formatted_data, "sf")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path") %in% names(formatted_data)))
expect_equal(nrow(formatted_data), 2)
expect_equal(ncol(formatted_data), 3)
expect_equal(nrow(formatted_data), 2)
expect_equal(ncol(formatted_data), 3)
test_that("format_deployment returns the correct formatted deployment data for songmeter device") {
test_that("format_deployment returns the correct formatted deployment data for songmeter device") {
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:05:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:06:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:10:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:11:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:15:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:16:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:20:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:21:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Create a temporary CSV file for testing
tmpfile <- tempfile(fileext = ".csv")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:05:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:06:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:10:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:11:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:15:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:16:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:20:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:21:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Test the function
formatted_data <- format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_s3_class(formatted_data, "sf")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path") %in% names(formatted_data)))
expect_equal(nrow(formatted_data), 2)
test_that("format_deployment returns the correct formatted deployment data for songmeter device") {
test_that("format_deployment returns the correct formatted deployment data for songmeter device", {
test_that("format_deployment returns the correct formatted deployment data for songmeter device", {
# Create a temporary TXT file for testing
tmpfile <- tempfile(fileext = ".txt")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:05:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:06:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:10:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:11:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:15:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:16:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:20:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:21:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Test the function
formatted_data <- format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_s3_class(formatted_data, "sf")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path") %in% names(formatted_data)))
expect_equal(nrow(formatted_data), 2)
expect_equal(ncol(formatted_data), 3)
})
test_that("format_deployment throws an error for unsupported devices", {
# Test if the function throws an error for unsupported device
expect_error(format_deployment("dummy.txt", device = "other_device"), "no other devices than songmeter supported")
})
devtools::test_active_file()
qe
)
devtools::test_active_file()
expect_equal(ncol(formatted_data), 4)
test_that("format_deployment returns the correct formatted deployment data for songmeter device", {
# Create a temporary TXT file for testing
tmpfile <- tempfile(fileext = ".txt")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:05:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:06:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:10:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:11:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:15:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:16:00,50.72196,N,7.50443,E,4.9,1
2024-Mar-12,12:20:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:21:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Test the function
formatted_data <- format_deployment(tmpfile, device = "songmeter")
# Check if the output has the correct structure and content
expect_s3_class(formatted_data, "sf")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path") %in% names(formatted_data)))
expect_equal(nrow(formatted_data), 1)
expect_equal(ncol(formatted_data), 4)
})
test_that("format_deployment throws an error for unsupported devices", {
# Test if the function throws an error for unsupported device
expect_error(format_deployment("dummy.txt", device = "other_device"), "no other devices than songmeter supported")
})
# Test if the function throws an error for unsupported device
expect_error(format_deployment("dummy.txt", device = "other_device"), "no other devices than songmeter supported")
devtools::test_active_file()
usethis::use_test("deployment_info")
# Create a temporary directory with test files
temp_dir <- tempdir()
dir.create(temp_dir)
# Create a sample _Summary.txt file
tmpfile <- file.path(temp_dir, "example_Summary.txt")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Mock the format_deployment function to avoid external dependencies
format_deployment_mock <- function(file, device) {
data <- read.csv(file)
data <- data.frame(
start_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC"),
end_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC") + 3600,
deployment_path = file
)
return(data)
}
# Replace format_deployment with the mocked version
assignInNamespace("format_deployment", format_deployment_mock, ns = asNamespace("your_package_name"))
# Replace format_deployment with the mocked version
assignInNamespace("format_deployment", format_deployment_mock, ns = asNamespace("singR"))
# Test the deployment_info function
deployments <- deployment_info(temp_dir)
# Check if the output has the correct structure and content
expect_s3_class(deployments, "data.frame")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path", "deployment_id") %in% names(deployments)))
expect_equal(nrow(deployments), 3)
expect_equal(ncol(deployments), 4)
test_that("deployment_info returns correct deployment information") {
test_that("deployment_info returns correct deployment information") {
test_that("deployment_info returns correct deployment information",{
# Create a temporary directory with test files
temp_dir <- tempdir()
dir.create(temp_dir)
# Create a sample _Summary.txt file
tmpfile <- file.path(temp_dir, "example_Summary.txt")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Mock the format_deployment function to avoid external dependencies
format_deployment_mock <- function(file, device) {
data <- read.csv(file)
data <- data.frame(
start_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC"),
end_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC") + 3600,
deployment_path = file
)
return(data)
}
# Replace format_deployment with the mocked version
assignInNamespace("format_deployment", format_deployment_mock, ns = asNamespace("singR"))
# Test the deployment_info function
deployments <- deployment_info(temp_dir)
# Check if the output has the correct structure and content
expect_s3_class(deployments, "data.frame")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path", "deployment_id") %in% names(deployments)))
expect_equal(nrow(deployments), 3)
expect_equal(ncol(deployments), 4)
})
# Clean up
test_that("deployment_info throws an error for non-existent directory", {
# Test if the function throws an error for non-existent directory
expect_error(deployment_info("non_existent_directory"), "cannot open the connection")
})
deployment_info("non_existent_directory")
# Test if the function throws an error for non-existent directory
expect_error(deployment_info("non_existent_directory"))
# Clean up
test_that("deployment_info throws an error for non-existent directory", {
# Test if the function throws an error for non-existent directory
expect_error(deployment_info("non_existent_directory"))
})
test_that("deployment_info returns correct deployment information",{
# Create a temporary directory with test files
temp_dir <- tempdir()
dir.create(temp_dir)
# Create a sample _Summary.txt file
tmpfile <- file.path(temp_dir, "example_Summary.txt")
writeLines("DATE,TIME,LAT,,LON,,POWER(V),#FILES
2024-Mar-08,07:34:00,50.72196,N,7.50443,E,5.0,0
2024-Mar-12,12:00:00,50.72196,N,7.50443,E,4.9,0
2024-Mar-12,12:01:00,50.72196,N,7.50443,E,4.9,1", tmpfile)
# Mock the format_deployment function to avoid external dependencies
format_deployment_mock <- function(file, device) {
data <- read.csv(file)
data <- data.frame(
start_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC"),
end_datetime = as.POSIXct(data$TIME, format = "%H:%M:%S", tz = "UTC") + 3600,
deployment_path = file
)
return(data)
}
# Replace format_deployment with the mocked version
assignInNamespace("format_deployment", format_deployment_mock, ns = asNamespace("singR"))
# Test the deployment_info function
deployments <- deployment_info(temp_dir)
# Check if the output has the correct structure and content
expect_s3_class(deployments, "data.frame")
expect_true(all(c("start_datetime", "end_datetime", "deployment_path", "deployment_id") %in% names(deployments)))
expect_equal(nrow(deployments), 3)
expect_equal(ncol(deployments), 4)
})
usethis::use_test("extract_path_info")
usethis::use_test("create_id_from_path")
test_that("create_id_from_path creates correct ID at data level", {
# Test the function at data level
path <- "/project1/region1/location1/deployment1/data.csv"
id <- create_id_from_path(path, level = "data")
expect_equal(id, "12c7abbbcf8bf5d44a1fc9316f4de059")
})
# Test the function at data level
path <- "/project1/region1/location1/deployment1/data.csv"
id <- create_id_from_path(path, level = "data")
id
stringr::str_replace_all(path, "/", "_")
digest::digest(stringr::str_replace_all(path, "/", "_"), algo = "md5")
# Test the function at data level
path <- "/project1/region1/location1/deployment1/some_directory/data.csv"
digest::digest(stringr::str_replace_all(path, "/", "_"), algo = "md5")
# Test the function at data level
path <- "project1/region1/location1/deployment1/some_directory/data.csv"
digest::digest(stringr::str_replace_all(path, "/", "_"), algo = "md5")
digest::digest(stringr::str_replace_all(path, "/", "_"), algo = "md5")
id <- create_id_from_path(path, level = "data")
id
# Test the function at data level
path <- "project1/region1/location1/deployment1/some_directory/data.csv"
id <- create_id_from_path(path, level = "data")
expect_equal(id, "f3fb934f4107b3f99ee3eaf384d1d8b2")
# Test the function at deployment_id level
path <- "/project1/region1/location1/deployment1/data.csv"
id <- create_id_from_path(path, level = "deployment_id")
path
id
digest::digest("project1_region1_location1_deployment1", algo = "md5")
id <- create_id_from_path(path, level = "deployment_id")
id
# Test the function at deployment_id level
path <- "project1/region1/location1/deployment1/some_directory/data.csv"
id <- create_id_from_path(path, level = "deployment_id")
id
digest::digest("project1_region1_location1_deployment1", algo = "md5")
create_id_from_path
extract_path_info(path, level = "deployment_id")
extract_path_info(path, level = "data")
extract_path_info(path, level = "data_dir")
# Test the function at deployment_id level
path <- "project1/region1/location1/deployment1/"
extract_path_info(path, level = "data_dir")
digest::digest("project1_region1_location1_deployment1", algo = "md5")
id <- create_id_from_path(path, level = "deployment_id")
extract_path_info(path, level = "deployment_id")
# Test the function at deployment_id level
path <- "project1/region1/location1/deployment1/summary.txt"
extract_path_info(path, level = "deployment_id")
# Test the function at deployment_id level
path <- "project1/region1/location1/deployment1"
extract_path_info(path, level = "deployment_id")
# Test the function at deployment_id level
path <- "blabla/project1/region1/location1/deployment1"
extract_path_info(path, level = "deployment_id")
# Test the function at deployment_id level
path <- "blabla/blabla/project1/region1/location1/deployment1"
extract_path_info(path, level = "deployment_id")
# Test the function at data level
path <- "blabla/project1/region1/location1/deployment1/some_directory/data.csv"
id <- create_id_from_path(path, level = "data")
extract_path_info(path, level = "deployment_id")
digest::digest("project1_region1_location1_deployment1", algo = "md5")
id <- create_id_from_path(path, level = "deployment_id")
id
extract_path_info(path, level = "deployment_id")
# Test the function at deployment_id level
path <- "blabla/blabla/project1/region1/location1/deployment1"
extract_path_info(path, level = "deployment_id")
digest::digest("project1_region1_location1_deployment1", algo = "md5")
id <- create_id_from_path(path, level = "deployment_id")
id
# Test the function at deployment_id level
path <- "blabla/blabla/project1/region1/location1/deployment1/summary.txt"
path
id <- create_id_from_path(path, level = "deployment_id")
expect_equal(id, "5106fac0fecd29dc9c9c4fa433d30b2a")
id
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::load_all()
devtools::test()
devtools::test()
# Test the function at data level
path <- "/project1/region1/location1/deployment1/deployment1/data.csv"
info <- extract_path_info(path, level = "data")
expect_equal(info$data, "data.csv")
expect_equal(info$data_dir, "deployment1")
expect_equal(info$deployment_id, "deployment1")
expect_equal(info$location_id, "location1")
expect_equal(info$region_id, "region1")
expect_equal(info$project_id, "project1")
test_that("extract_path_info extracts correct path information at data level", {
# Test the function at data level
path <- "/project1/region1/location1/deployment1/deployment1/data.csv"
info <- extract_path_info(path, level = "data")
expect_equal(info$data, "data.csv")
expect_equal(info$data_dir, "deployment1")
expect_equal(info$deployment_id, "deployment1")
expect_equal(info$location_id, "location1")
expect_equal(info$region_id, "region1")
expect_equal(info$project_id, "project1")
})
path <- dirname(path)
info <- extract_path_info(path, level = "deployment_id")
expect_equal(info$deployment_id, "deployment1")
expect_equal(info$location_id, "location1")
path
# Test the function at deployment_id level
path <- "/project1/region1/location1/deployment1/data.csv"
path <- dirname(path)
info <- extract_path_info(path, level = "deployment_id")
expect_equal(info$deployment_id, "deployment1")
expect_equal(info$location_id, "location1")
expect_equal(info$region_id, "region1")
expect_equal(info$project_id, "project1")
devtools::test()
devtools::test()
